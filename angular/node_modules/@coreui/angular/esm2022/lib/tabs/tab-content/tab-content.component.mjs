import { ChangeDetectionStrategy, Component, ContentChildren, EventEmitter, HostBinding, Input, numberAttribute, Output } from '@angular/core';
import { TabPaneComponent } from '../tab-pane/tab-pane.component';
import * as i0 from "@angular/core";
import * as i1 from "../tab.service";
export class TabContentComponent {
    /**
     * Set active tabPane index
     * @type number
     */
    set activeTabPaneIdx(value) {
        const newValue = value;
        if (this._activeTabPaneIdx != newValue) {
            this._activeTabPaneIdx = newValue;
            this.activeTabPaneIdxChange.emit(newValue);
            this.changeDetectorRef.markForCheck();
            this.changeDetectorRef.detectChanges();
        }
    }
    ;
    get activeTabPaneIdx() {
        return this._activeTabPaneIdx;
    }
    constructor(changeDetectorRef, tabService) {
        this.changeDetectorRef = changeDetectorRef;
        this.tabService = tabService;
        this._activeTabPaneIdx = -1;
        /**
         * Event emitted on the active tab pane index change.
         */
        this.activeTabPaneIdxChange = new EventEmitter();
    }
    get hostClasses() {
        return {
            'tab-content': true
        };
    }
    ngAfterContentInit() {
        this.subscribeTabService();
    }
    ngAfterContentChecked() {
        this.panes?.forEach((tabPane, index) => {
            tabPane.tabContent = this;
            tabPane.tabPaneIdx = index;
        });
        this.refreshTabPaneActive(this.activeTabPaneIdx);
        this.tabService.setActiveTabIdx({ tabContent: this, activeIdx: this.activeTabPaneIdx });
    }
    ngOnChanges(changes) {
        if (changes['activeTabPaneIdx']?.currentValue) {
            this.tabService.setActiveTabIdx({ tabContent: this, activeIdx: changes['activeTabPaneIdx'].currentValue });
        }
    }
    ngOnDestroy() {
        this.subscribeTabService(false);
    }
    subscribeTabService(subscribe = true) {
        if (subscribe) {
            this.tabServiceSubscription = this.tabService.activeTabPaneIdx$.subscribe((tabContentState) => {
                if (this === tabContentState.tabContent) {
                    this.activeTabPaneIdx = tabContentState.activeIdx;
                }
            });
        }
        else {
            this.tabServiceSubscription?.unsubscribe();
        }
    }
    refreshTabPaneActive(idx) {
        // hack for active state pane refresh todo?
        this.panes?.forEach((tabPane, index) => {
            tabPane.active = idx === index;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.4", ngImport: i0, type: TabContentComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.TabService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "17.3.4", type: TabContentComponent, isStandalone: true, selector: "c-tab-content", inputs: { activeTabPaneIdx: ["activeTabPaneIdx", "activeTabPaneIdx", numberAttribute] }, outputs: { activeTabPaneIdxChange: "activeTabPaneIdxChange" }, host: { properties: { "class": "this.hostClasses" } }, queries: [{ propertyName: "panes", predicate: TabPaneComponent }], exportAs: ["cTabContent"], usesOnChanges: true, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.4", ngImport: i0, type: TabContentComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-tab-content', template: '<ng-content />', changeDetection: ChangeDetectionStrategy.OnPush, exportAs: 'cTabContent', standalone: true, styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i1.TabService }], propDecorators: { activeTabPaneIdx: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], activeTabPaneIdxChange: [{
                type: Output
            }], panes: [{
                type: ContentChildren,
                args: [TabPaneComponent]
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLWNvbnRlbnQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZXVpLWFuZ3VsYXIvc3JjL2xpYi90YWJzL3RhYi1jb250ZW50L3RhYi1jb250ZW50LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBR0wsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsWUFBWSxFQUNaLFdBQVcsRUFDWCxLQUFLLEVBQ0wsZUFBZSxFQUdmLE1BQU0sRUFHUCxNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQzs7O0FBV2xFLE1BQU0sT0FBTyxtQkFBbUI7SUFFOUI7OztPQUdHO0lBQ0gsSUFDSSxnQkFBZ0IsQ0FBQyxLQUFhO1FBQ2hDLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQztRQUN2QixJQUFJLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxRQUFRLEVBQUUsQ0FBQztZQUN2QyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsUUFBUSxDQUFDO1lBQ2xDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3RDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUN6QyxDQUFDO0lBQ0gsQ0FBQztJQUFBLENBQUM7SUFFRixJQUFJLGdCQUFnQjtRQUNsQixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztJQUNoQyxDQUFDO0lBWUQsWUFDVSxpQkFBb0MsRUFDcEMsVUFBc0I7UUFEdEIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUNwQyxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBWnhCLHNCQUFpQixHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRS9COztXQUVHO1FBQ08sMkJBQXNCLEdBQXlCLElBQUksWUFBWSxFQUFVLENBQUM7SUFRaEYsQ0FBQztJQUVMLElBQ0ksV0FBVztRQUNiLE9BQU87WUFDTCxhQUFhLEVBQUUsSUFBSTtTQUNwQixDQUFDO0lBQ0osQ0FBQztJQUVELGtCQUFrQjtRQUNoQixJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQscUJBQXFCO1FBQ25CLElBQUksQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ3JDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO1lBQzFCLE9BQU8sQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQzdCLENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQztJQUMxRixDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksT0FBTyxDQUFDLGtCQUFrQixDQUFDLEVBQUUsWUFBWSxFQUFFLENBQUM7WUFDOUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO1FBQzdHLENBQUM7SUFDSCxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQsbUJBQW1CLENBQUMsWUFBcUIsSUFBSTtRQUMzQyxJQUFJLFNBQVMsRUFBRSxDQUFDO1lBQ2QsSUFBSSxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUMsZUFBZSxFQUFFLEVBQUU7Z0JBQzVGLElBQUksSUFBSSxLQUFLLGVBQWUsQ0FBQyxVQUFVLEVBQUUsQ0FBQztvQkFDeEMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLGVBQWUsQ0FBQyxTQUFTLENBQUM7Z0JBQ3BELENBQUM7WUFDSCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUM7YUFBTSxDQUFDO1lBQ04sSUFBSSxDQUFDLHNCQUFzQixFQUFFLFdBQVcsRUFBRSxDQUFDO1FBQzdDLENBQUM7SUFDSCxDQUFDO0lBRUQsb0JBQW9CLENBQUMsR0FBVztRQUM5QiwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDckMsT0FBTyxDQUFDLE1BQU0sR0FBRyxHQUFHLEtBQUssS0FBSyxDQUFDO1FBQ2pDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs4R0FuRlUsbUJBQW1CO2tHQUFuQixtQkFBbUIsc0hBTVYsZUFBZSx5S0FzQmxCLGdCQUFnQiw2RUFsQ3ZCLGdCQUFnQjs7MkZBTWYsbUJBQW1CO2tCQVIvQixTQUFTOytCQUNFLGVBQWUsWUFDZixnQkFBZ0IsbUJBRVQsdUJBQXVCLENBQUMsTUFBTSxZQUNyQyxhQUFhLGNBQ1gsSUFBSTsrR0FTWixnQkFBZ0I7c0JBRG5CLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZUFBZSxFQUFFO2dCQW9CM0Isc0JBQXNCO3NCQUEvQixNQUFNO2dCQUVtQyxLQUFLO3NCQUE5QyxlQUFlO3VCQUFDLGdCQUFnQjtnQkFTN0IsV0FBVztzQkFEZCxXQUFXO3VCQUFDLE9BQU8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlckNvbnRlbnRDaGVja2VkLFxuICBBZnRlckNvbnRlbnRJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBJbnB1dCxcbiAgbnVtYmVyQXR0cmlidXRlLFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgVGFiUGFuZUNvbXBvbmVudCB9IGZyb20gJy4uL3RhYi1wYW5lL3RhYi1wYW5lLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUYWJTZXJ2aWNlIH0gZnJvbSAnLi4vdGFiLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjLXRhYi1jb250ZW50JyxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudCAvPicsXG4gIHN0eWxlVXJsczogWycuL3RhYi1jb250ZW50LmNvbXBvbmVudC5zY3NzJ10sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBleHBvcnRBczogJ2NUYWJDb250ZW50JyxcbiAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBUYWJDb250ZW50Q29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuXG4gIC8qKlxuICAgKiBTZXQgYWN0aXZlIHRhYlBhbmUgaW5kZXhcbiAgICogQHR5cGUgbnVtYmVyXG4gICAqL1xuICBASW5wdXQoeyB0cmFuc2Zvcm06IG51bWJlckF0dHJpYnV0ZSB9KVxuICBzZXQgYWN0aXZlVGFiUGFuZUlkeCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAodGhpcy5fYWN0aXZlVGFiUGFuZUlkeCAhPSBuZXdWYWx1ZSkge1xuICAgICAgdGhpcy5fYWN0aXZlVGFiUGFuZUlkeCA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5hY3RpdmVUYWJQYW5lSWR4Q2hhbmdlLmVtaXQobmV3VmFsdWUpO1xuICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgfTtcblxuICBnZXQgYWN0aXZlVGFiUGFuZUlkeCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlVGFiUGFuZUlkeDtcbiAgfVxuXG4gIHByaXZhdGUgX2FjdGl2ZVRhYlBhbmVJZHggPSAtMTtcblxuICAvKipcbiAgICogRXZlbnQgZW1pdHRlZCBvbiB0aGUgYWN0aXZlIHRhYiBwYW5lIGluZGV4IGNoYW5nZS5cbiAgICovXG4gIEBPdXRwdXQoKSBhY3RpdmVUYWJQYW5lSWR4Q2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIEBDb250ZW50Q2hpbGRyZW4oVGFiUGFuZUNvbXBvbmVudCkgcHVibGljIHBhbmVzITogUXVlcnlMaXN0PFRhYlBhbmVDb21wb25lbnQ+O1xuICBwcml2YXRlIHRhYlNlcnZpY2VTdWJzY3JpcHRpb24hOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSB0YWJTZXJ2aWNlOiBUYWJTZXJ2aWNlXG4gICkgeyB9XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gIGdldCBob3N0Q2xhc3NlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ3RhYi1jb250ZW50JzogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpYmVUYWJTZXJ2aWNlKCk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKTogdm9pZCB7XG4gICAgdGhpcy5wYW5lcz8uZm9yRWFjaCgodGFiUGFuZSwgaW5kZXgpID0+IHtcbiAgICAgIHRhYlBhbmUudGFiQ29udGVudCA9IHRoaXM7XG4gICAgICB0YWJQYW5lLnRhYlBhbmVJZHggPSBpbmRleDtcbiAgICB9KTtcbiAgICB0aGlzLnJlZnJlc2hUYWJQYW5lQWN0aXZlKHRoaXMuYWN0aXZlVGFiUGFuZUlkeCk7XG4gICAgdGhpcy50YWJTZXJ2aWNlLnNldEFjdGl2ZVRhYklkeCh7IHRhYkNvbnRlbnQ6IHRoaXMsIGFjdGl2ZUlkeDogdGhpcy5hY3RpdmVUYWJQYW5lSWR4IH0pO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2VzWydhY3RpdmVUYWJQYW5lSWR4J10/LmN1cnJlbnRWYWx1ZSkge1xuICAgICAgdGhpcy50YWJTZXJ2aWNlLnNldEFjdGl2ZVRhYklkeCh7IHRhYkNvbnRlbnQ6IHRoaXMsIGFjdGl2ZUlkeDogY2hhbmdlc1snYWN0aXZlVGFiUGFuZUlkeCddLmN1cnJlbnRWYWx1ZSB9KTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmliZVRhYlNlcnZpY2UoZmFsc2UpO1xuICB9XG5cbiAgc3Vic2NyaWJlVGFiU2VydmljZShzdWJzY3JpYmU6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgaWYgKHN1YnNjcmliZSkge1xuICAgICAgdGhpcy50YWJTZXJ2aWNlU3Vic2NyaXB0aW9uID0gdGhpcy50YWJTZXJ2aWNlLmFjdGl2ZVRhYlBhbmVJZHgkLnN1YnNjcmliZSgodGFiQ29udGVudFN0YXRlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzID09PSB0YWJDb250ZW50U3RhdGUudGFiQ29udGVudCkge1xuICAgICAgICAgIHRoaXMuYWN0aXZlVGFiUGFuZUlkeCA9IHRhYkNvbnRlbnRTdGF0ZS5hY3RpdmVJZHg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhYlNlcnZpY2VTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgcmVmcmVzaFRhYlBhbmVBY3RpdmUoaWR4OiBudW1iZXIpIHtcbiAgICAvLyBoYWNrIGZvciBhY3RpdmUgc3RhdGUgcGFuZSByZWZyZXNoIHRvZG8/XG4gICAgdGhpcy5wYW5lcz8uZm9yRWFjaCgodGFiUGFuZSwgaW5kZXgpID0+IHtcbiAgICAgIHRhYlBhbmUuYWN0aXZlID0gaWR4ID09PSBpbmRleDtcbiAgICB9KTtcbiAgfVxufVxuIl19